From: Ralf Glaser <glaser@iotmaxx.de>
Date: Mon, 5 Aug 2024 13:57:25 +0000
Subject: [PATCH] ARM-i.MX7-add-support-for-iotmaxx-gw4100-1

---
 arch/arm/boards/iotmaxx-gw4100/Makefile            |   2 +
 arch/arm/boards/iotmaxx-gw4100/board.c             | 288 +++++++++++++++++++++
 arch/arm/boards/iotmaxx-gw4100/eeprom_data.h       |  80 ++++++
 .../flash-header-iotmaxx-imx7d-gw4100.imxcfg       |  83 ++++++
 arch/arm/boards/iotmaxx-gw4100/lowlevel.c          |  44 ++++
 arch/arm/dts/imx7d-iotmaxx-gw4100.dts              | 147 +++++++++++
 6 files changed, 644 insertions(+)
 create mode 100644 arch/arm/boards/iotmaxx-gw4100/Makefile
 create mode 100644 arch/arm/boards/iotmaxx-gw4100/board.c
 create mode 100644 arch/arm/boards/iotmaxx-gw4100/eeprom_data.h
 create mode 100644 arch/arm/boards/iotmaxx-gw4100/flash-header-iotmaxx-imx7d-gw4100.imxcfg
 create mode 100644 arch/arm/boards/iotmaxx-gw4100/lowlevel.c
 create mode 100644 arch/arm/dts/imx7d-iotmaxx-gw4100.dts

diff --git a/arch/arm/boards/iotmaxx-gw4100/Makefile b/arch/arm/boards/iotmaxx-gw4100/Makefile
new file mode 100644
index 000000000000..01c7a259e9a5
--- /dev/null
+++ b/arch/arm/boards/iotmaxx-gw4100/Makefile
@@ -0,0 +1,2 @@
+obj-y += board.o
+lwl-y += lowlevel.o
diff --git a/arch/arm/boards/iotmaxx-gw4100/board.c b/arch/arm/boards/iotmaxx-gw4100/board.c
new file mode 100644
index 000000000000..58ba3c0869c1
--- /dev/null
+++ b/arch/arm/boards/iotmaxx-gw4100/board.c
@@ -0,0 +1,288 @@
+#include <bootsource.h>
+#include <common.h>
+#include <fs.h>
+#include <init.h>
+#include <io.h>
+#include <globalvar.h>
+#include <gpio.h>
+#include <libfile.h>
+#include <linux/micrel_phy.h>
+#include <linux/phy.h>
+#include <mach/bbu.h>
+#include <mach/generic.h>
+#include <mach/imx7-regs.h>
+#include <mach/iomux-mx7.h>
+#include <magicvar.h>
+#include <mfd/imx7-iomuxc-gpr.h>
+#include <net.h>
+
+#include <phy-id-list.h>
+#include "eeprom_data.h"
+
+static const struct gpio gw4100_expansion_gpio_list[] = {
+	/* PCM related signals, shared with the modem */
+	{ .gpio = IMX_GPIO_NR(5, 5), .label = "pcm-dout", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(5, 6), .label = "pcm-clk", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(5, 7), .label = "pcm-sync", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(5, 8), .label = "pcm-din", .flags = GPIOF_IN, },
+
+	/* SPI related signals */
+	{ .gpio = IMX_GPIO_NR(6, 19), .label = "spi-miso", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 20), .label = "spi-mosi", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 21), .label = "spi-clk", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 22), .label = "spi-cs", .flags = GPIOF_IN, },
+
+	/* SAI related signals */
+	{ .gpio = IMX_GPIO_NR(6, 12), .label = "sai-rxd", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 13), .label = "sai-txc", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 14), .label = "sai-txf", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 15), .label = "sai-txd", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 16), .label = "sai-rxf", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 17), .label = "sai-rxc", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(6, 18), .label = "sai-mclk", .flags = GPIOF_IN, },
+
+	/* GPIO related signals */
+	{ .gpio = IMX_GPIO_NR(7, 11), .label = "io00", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 10), .label = "io01", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 12), .label = "io02", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 2), .label = "io03", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 3), .label = "io04", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 5), .label = "io05", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 4), .label = "io06", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 13), .label = "io07", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 7), .label = "io08", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 14), .label = "io09", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(7, 6), .label = "io10", .flags = GPIOF_IN, },
+
+	/* UART related signals */
+	{ .gpio = IMX_GPIO_NR(3, 3), .label = "exp-cts", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(3, 2), .label = "exp-rts", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(3, 1), .label = "exp-txd", .flags = GPIOF_IN, },
+	{ .gpio = IMX_GPIO_NR(3, 0), .label = "exp-rxd", .flags = GPIOF_IN, },
+};
+
+/* PAD setup: 100 k PullUp + Slow Slew Rate */
+#define DEF_PU (0x74)
+
+static const iomux_v3_cfg_t gw4100_expansion_pad_list[] = {
+	/* PCM related signals, shared with the modem */
+	MX7D_PAD_SD1_DATA0__GPIO5_IO5, /* input, passive */
+	MX7D_PAD_SD1_DATA1__GPIO5_IO6, /* input, passive */
+	MX7D_PAD_SD1_DATA2__GPIO5_IO7, /* input, passive */
+	MX7D_PAD_SD1_DATA3__GPIO5_IO8, /* input, passive */
+
+	/* SPI related signals */
+	MX7D_PAD_SAI2_TX_DATA__GPIO6_IO22 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI2_TX_BCLK__GPIO6_IO20 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI2_TX_SYNC__GPIO6_IO19 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI2_RX_DATA__GPIO6_IO21 | DEF_PU, /* input, 100k PU */
+
+	/* SAI related signals */
+	MX7D_PAD_SAI1_RX_DATA__GPIO6_IO12 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI1_TX_DATA__GPIO6_IO15 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI1_MCLK__GPIO6_IO18 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI1_TX_BCLK__GPIO6_IO13 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI1_RX_BCLK__GPIO6_IO17 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI1_RX_SYNC__GPIO6_IO16 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_SAI1_TX_SYNC__GPIO6_IO14 | DEF_PU, /* input, 100k PU */
+
+	/* GPIO related signals */
+	MX7D_PAD_ENET1_RGMII_TXC__GPIO7_IO11 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_TX_CTL__GPIO7_IO10 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_TX_CLK__GPIO7_IO12 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_RD2__GPIO7_IO2 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_RD3__GPIO7_IO3 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_RXC__GPIO7_IO5 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_RX_CTL__GPIO7_IO4 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_TD1__GPIO7_IO7 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_CRS__GPIO7_IO14 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_ENET1_RGMII_TD0__GPIO7_IO6 | DEF_PU, /* input, 100k PU */
+
+	/* UART related signals */
+	MX7D_PAD_LCD_VSYNC__GPIO3_IO3 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_LCD_HSYNC__GPIO3_IO2 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_LCD_ENABLE__GPIO3_IO1 | DEF_PU, /* input, 100k PU */
+	MX7D_PAD_LCD_CLK__GPIO3_IO0 | DEF_PU, /* input, 100k PU */
+};
+
+static int imx7d_iotmaxx_read_eeprom(const char *file, struct eepromData *data)
+{
+	int fd;
+	int ret;
+
+	fd = open(file, O_RDONLY);
+	if (fd < 0) {
+		ret = fd;
+		goto err;
+	}
+
+	ret = read_full(fd, data, sizeof(*data));
+	if (ret < 0)
+		goto err_open;
+
+	ret = 0;
+
+err_open:
+	close(fd);
+err:
+	return ret;
+}
+
+static int imx7d_iotmaxx_detect_expansion_board(void)
+{
+	static char *gw4100_overlays;
+	struct eepromData data;
+	char overlay_name[17];
+	int ret;
+
+	memset(&data, 0, sizeof(struct eepromData));
+
+	ret = imx7d_iotmaxx_read_eeprom("/dev/eeprom1", &data);
+	/* no eeprom found can simple mean that there is no expansion board */
+	if (ret == -ENOENT)
+		return 0;
+	else if (ret)
+		return ret;
+
+	if (!eeprom_data_valid(&data))
+		return -EINVAL;
+
+	/* be sure to have a real string with \0 termination */
+	strncpy(overlay_name, data.sectionA.commonData.caOverlayName, 16);
+	overlay_name[16] = '\0';
+
+	if (strlen(overlay_name) <= 0)
+		return -ENOENT;
+
+	gw4100_overlays = basprintf("/boot/overlays/%s.dtbo", overlay_name);
+
+	globalvar_add_simple_string("boot.overlays", &gw4100_overlays);
+
+	return 0;
+}
+
+/**
+ * We need a safe pad setup for the expansion port if it isn't in use.
+ * - we cannot adapt the bootloader's DTS, because it should share it with the kernel
+ * - we cannot adapt the Kernel DTS, since it must be adaptable via DTS overlay
+ *
+ * So we must do this pad setup in C code here.
+ *
+ * Refer BSPs documentation in section "Expansion Board Connector" about the
+ * required/intended pad setup.
+ *
+ * If an expansion board is connected, the bootloader will detect its presence
+ * and discovers the required device tree overlay. The final pad setup in order
+ * to make use of the attached expansion board is done in the Linux kernel.
+ */
+static int  imx7d_iotmaxx_expansion_port_setup(void)
+{
+	int rc;
+
+	if (!of_machine_is_compatible("iotmaxx,imx7d-gw4100"))
+		return 0;
+
+	rc = mxc_iomux_v3_setup_multiple_pads(gw4100_expansion_pad_list, ARRAY_SIZE(gw4100_expansion_pad_list));
+	if (rc != 0)
+		pr_err("Failed to setup expansion port SoC pad features. Trying to continue.\n");
+
+	rc = gpio_request_array(gw4100_expansion_gpio_list, ARRAY_SIZE(gw4100_expansion_gpio_list));
+	if (rc != 0)
+		pr_err("Failed to setup expansion port SoC pads. Trying to continue.\n");
+
+	imx7d_iotmaxx_detect_expansion_board();
+
+	return 0;
+}
+device_initcall(imx7d_iotmaxx_expansion_port_setup);
+
+static int ksz8081_phy_fixup(struct phy_device *dev)
+{
+	/* Set 50MHz-Clock mode */
+	phy_write(dev, 0x1f, BIT(7));
+
+	return 0;
+}
+
+static int imx7d_iotmaxx_gateway_dev_init(void)
+{
+	if (!of_machine_is_compatible("iotmaxx,imx7d-gw4100"))
+		return 0;
+
+	barebox_set_hostname("iotmaxx-gw4100");
+
+	switch (bootsource_get_instance()) {
+	case 1:
+		of_device_enable_path("/chosen/environment-sd");
+		break;
+	case 2:
+		of_device_enable_path("/chosen/environment-emmc");
+		break;
+	}
+
+	imx7_bbu_internal_mmcboot_register_handler("emmc", "/dev/mmc2", 1);
+
+	return 0;
+}
+device_initcall(imx7d_iotmaxx_gateway_dev_init);
+
+static void imx7d_iotmaxx_gateway_init_fec(void)
+{
+	void __iomem *gpr = IOMEM(MX7_IOMUXC_GPR_BASE_ADDR);
+	uint32_t gpr1;
+
+	/*
+	 * Make sure we drive ENETn_TX_CLK signal
+	 */
+	gpr1 = readl(gpr + IOMUXC_GPR1);
+	gpr1 |=  IMX7D_GPR1_ENET2_CLK_DIR_MASK;
+	gpr1 &= ~IMX7D_GPR1_ENET2_TX_CLK_SEL_MASK;
+	writel(gpr1, gpr + IOMUXC_GPR1);
+}
+
+static int imx7d_iotmaxx_gateway_coredevices_init(void)
+{
+	if (!of_machine_is_compatible("iotmaxx,imx7d-gw4100"))
+		return 0;
+
+	imx7d_iotmaxx_gateway_init_fec();
+
+	phy_register_fixup_for_uid(PHY_ID_KSZ8081, MICREL_PHY_ID_MASK,
+				   ksz8081_phy_fixup);
+
+	return 0;
+}
+coredevice_initcall(imx7d_iotmaxx_gateway_coredevices_init);
+
+static int imx7d_iotmaxx_gateway_ethernet_init(void)
+{
+	const char * const alias = "ethernet0";
+	struct device_node *np, *root;
+	struct eepromData data;
+	int ret;
+
+	memset(&data, 0, sizeof(struct eepromData));
+
+	ret = imx7d_iotmaxx_read_eeprom("/dev/eeprom0", &data);
+	if (ret) {
+		pr_err("can not read eeprom0 (%s)\n", strerror(ret));
+		return ret;
+	}
+
+	if (!eeprom_data_valid(&data))
+		return -EINVAL;
+
+	root = of_get_root_node();
+
+	np = of_find_node_by_alias(root, alias);
+	if (!np) {
+		pr_warn("Failed to find %s\n", alias);
+		return -ENOENT;
+	}
+
+	of_eth_register_ethaddr(np, data.sectionB.specificData.u8aMAC);
+
+	return 0;
+}
+late_initcall(imx7d_iotmaxx_gateway_ethernet_init);
diff --git a/arch/arm/boards/iotmaxx-gw4100/eeprom_data.h b/arch/arm/boards/iotmaxx-gw4100/eeprom_data.h
new file mode 100644
index 000000000000..be778a0ea45f
--- /dev/null
+++ b/arch/arm/boards/iotmaxx-gw4100/eeprom_data.h
@@ -0,0 +1,80 @@
+#ifndef __EEPROM_DATA_H_
+#define __EEPROM_DATA_H_
+
+#define IOTMAXX_MAGIC      0xC4EC31B6
+
+struct sVersion {
+	uint8_t u8Major;
+	uint8_t u8Minor;
+	uint8_t u8Build;
+};
+
+union uVersion {
+	uint32_t u32Version;
+	struct sVersion sVersion;
+};
+
+struct eeCommonData {
+	uint32_t    u32Magic;                       // magic number
+	uint32_t    u32Checksum;                    // section checksum (not including u32Magic and u32Checksum)
+	char        caOverlayName[16];              // name of overlay (e.g. 'test' for test.dto)
+	uint32_t    u32Product;                     // product id
+	union       uVersion uVersion;            // product version
+	char        caProductName[16];              // name of product (human readable)
+	char        caSerialNumber[16];             // serial number of product (e.g. IMEI)
+	uint8_t     u8Manufacturer;                 // manufacturer of product (iotmaxx assigned id)
+	uint32_t    u32TimeOfProduction;            // time of production (unix timestamp)
+	uint8_t     u8Tester;                       // tested by (iotmaxx assigned id)
+	uint8_t     u8TestResult;                   // test result (tbd)
+	uint32_t    u32TimeOfTest;                  // time of test (unix timestamp)
+};
+
+struct eeSpecificData {
+	uint32_t    u32Magic;                       // magic number
+	uint32_t    u32Checksum;                    // section checksum (not including u32Magic and u32Checksum)
+	uint8_t     u8aMAC[6];                      // MAC address
+};
+
+struct eeSectionCData {
+	uint32_t    u32Magic;                       // magic number
+	uint32_t    u32Checksum;                    // section checksum (not including u32Magic and u32Checksum)
+};
+
+struct eeCertificates {
+	uint32_t    u32Magic;                       // magic number
+	uint32_t    u32Checksum;                    // section checksum (not including u32Magic and u32Checksum)
+};
+
+struct eeUserData {
+	uint32_t    u32Magic;                       // magic number
+	uint32_t    u32Checksum;                    // section checksum (not including u32Magic and u32Checksum)
+};
+
+struct eepromData {
+	union {
+		uint8_t u8aSectionA[256];
+		struct eeCommonData commonData;
+	} sectionA;		                            // data common for all boards
+	union {
+		uint8_t u8aSectionB[256];
+		struct eeSpecificData specificData;
+	} sectionB;                                         // board specifc data
+	union {
+		uint8_t u8aSectionC[512];
+		struct eeSectionCData sectionCData;
+	} sectionC;                                         // unused
+	union {
+		uint8_t u8aSectionD[3*1024];
+		struct eeCertificates certificates;
+	} sectionD;                                         // certificates
+	union {
+		uint8_t u8aSectionD[4*1024];
+		struct eeUserData userData;
+	} sectionE;                                         // user data, application/project specific
+};
+
+static inline int eeprom_data_valid(struct eepromData *data)
+{
+	return data->sectionA.commonData.u32Magic == IOTMAXX_MAGIC ? 1 : 0;
+}
+#endif // __EEPROM_DATA_H_
diff --git a/arch/arm/boards/iotmaxx-gw4100/flash-header-iotmaxx-imx7d-gw4100.imxcfg b/arch/arm/boards/iotmaxx-gw4100/flash-header-iotmaxx-imx7d-gw4100.imxcfg
new file mode 100644
index 000000000000..149b8516a09f
--- /dev/null
+++ b/arch/arm/boards/iotmaxx-gw4100/flash-header-iotmaxx-imx7d-gw4100.imxcfg
@@ -0,0 +1,83 @@
+soc imx7
+loadaddr 0x80000000
+ivtofs 0x400
+
+/*
+ * Copyright (C) 2016 NXP Semiconductors
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ *
+ * Taken from upstream U-Boot git://git.denx.de/u-boot.git, commit
+ * 1a8150d4b16fbafa6f1d207ddb85eda7dc399e2d
+ */
+
+#include <mach/imx7-ddr-regs.h>
+
+wm 32 0x30340004 0x4F400005
+
+wm 32 0x30391000 0x00000003
+wm 32 0x30391000 0x00000002
+
+wm 32 MX7_DDRC_MSTR 0x01040001
+wm 32 MX7_DDRC_DFIUPD0 0x80400003
+wm 32 MX7_DDRC_DFIUPD1 0x00100020
+wm 32 MX7_DDRC_DFIUPD2 0x80100004
+wm 32 MX7_DDRC_RFSHTMG 0x00400046
+wm 32 MX7_DDRC_MP_PCTRL_0 0x00000001
+wm 32 MX7_DDRC_INIT0 0x00020083
+wm 32 MX7_DDRC_INIT1 0x00690000
+wm 32 MX7_DDRC_INIT3 0x09300004
+wm 32 MX7_DDRC_INIT4 0x04080000
+wm 32 MX7_DDRC_INIT5 0x00100004
+wm 32 MX7_DDRC_RANKCTL 0x0000033f
+wm 32 MX7_DDRC_DRAMTMG0 0x09081109
+wm 32 MX7_DDRC_DRAMTMG1 0x0007020d
+wm 32 MX7_DDRC_DRAMTMG2 0x03040407
+wm 32 MX7_DDRC_DRAMTMG3 0x00002006
+wm 32 MX7_DDRC_DRAMTMG4 0x04020205
+wm 32 MX7_DDRC_DRAMTMG5 0x03030202
+wm 32 MX7_DDRC_DRAMTMG8 0x00000803
+wm 32 MX7_DDRC_ZQCTL0 0x00800020
+wm 32 MX7_DDRC_ZQCTL1 0x02000100
+wm 32 MX7_DDRC_DFITMG0 0x02098204
+wm 32 MX7_DDRC_DFITMG1 0x00030303
+wm 32 MX7_DDRC_ADDRMAP0 0x00000016
+wm 32 MX7_DDRC_ADDRMAP1 0x00171717
+wm 32 MX7_DDRC_ADDRMAP5 0x04040404
+wm 32 MX7_DDRC_ADDRMAP6 0x0f040404
+wm 32 MX7_DDRC_ODTCFG 0x06000604
+wm 32 MX7_DDRC_ODTMAP 0x00000001
+
+wm 32 0x30391000 0x00000000
+
+wm 32 MX7_DDR_PHY_PHY_CON0 0x17420f40
+wm 32 MX7_DDR_PHY_PHY_CON1 0x10210100
+wm 32 MX7_DDR_PHY_PHY_CON4 0x00060807
+wm 32 MX7_DDR_PHY_MDLL_CON0 0x1010007e
+wm 32 MX7_DDR_PHY_DRVDS_CON0 0x00000d6e
+wm 32 MX7_DDR_PHY_OFFSET_RD_CON0 0x08080808
+wm 32 MX7_DDR_PHY_OFFSET_WR_CON0 0x08080808
+wm 32 MX7_DDR_PHY_CMD_SDLL_CON0 0x01000010
+wm 32 MX7_DDR_PHY_CMD_SDLL_CON0 0x00000010
+
+wm 32 MX7_DDR_PHY_ZQ_CON0 0x0e407304
+wm 32 MX7_DDR_PHY_ZQ_CON0 0x0e447304
+wm 32 MX7_DDR_PHY_ZQ_CON0 0x0e447306
+
+check 32 until_any_bit_set MX7_DDR_PHY_ZQ_CON1 0x1
+
+wm 32 MX7_DDR_PHY_ZQ_CON0 0x0e447304
+wm 32 MX7_DDR_PHY_ZQ_CON0 0x0e407304
+
+wm 32 0x30384130 0x00000000
+wm 32 0x30340020 0x00000178
+wm 32 0x30384130 0x00000002
+
+wm 32 MX7_DDR_PHY_LP_CON0 0x0000000f
+
+check 32 until_any_bit_set MX7_DDRC_STAT 0x1
diff --git a/arch/arm/boards/iotmaxx-gw4100/lowlevel.c b/arch/arm/boards/iotmaxx-gw4100/lowlevel.c
new file mode 100644
index 000000000000..1d24256cda11
--- /dev/null
+++ b/arch/arm/boards/iotmaxx-gw4100/lowlevel.c
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0+
+#include <debug_ll.h>
+#include <io.h>
+#include <common.h>
+#include <linux/sizes.h>
+#include <mach/generic.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/imx7-ccm-regs.h>
+#include <mach/iomux-mx7.h>
+#include <mach/debug_ll.h>
+#include <asm/cache.h>
+#include <mach/esdctl.h>
+
+extern char __dtb_z_imx7d_iotmaxx_gw4100_start[];
+
+static inline void setup_uart(void)
+{
+	void __iomem *ccm = IOMEM(MX7_CCM_BASE_ADDR);
+
+	writel(IMX7_CCM_CCGR_SETTINGn_NEEDED(0),
+	       ccm + IMX7_CCM_CCGRn_CLR(IMX7_CCM_CCGR_UART3));
+	writel(IMX7_CCM_TARGET_ROOTn_ENABLE | IMX7_UART2_CLK_ROOT__OSC_24M,
+	       ccm + IMX7_CCM_TARGET_ROOTn(IMX7_UART3_CLK_ROOT));
+	writel(IMX7_CCM_CCGR_SETTINGn_NEEDED(0),
+	       ccm + IMX7_CCM_CCGRn_SET(IMX7_CCM_CCGR_UART3));
+
+	imx7_setup_pad(MX7D_PAD_UART3_TX_DATA__UART3_DCE_TX);
+
+	imx7_uart_setup_ll();
+
+	putc_ll('>');
+}
+
+ENTRY_FUNCTION(start_imx7d_iotmaxx_gw4100, r0, r1, r2)
+{
+	imx7_cpu_lowlevel_init();
+
+	if (IS_ENABLED(CONFIG_DEBUG_LL))
+		setup_uart();
+
+	imx7d_barebox_entry(__dtb_z_imx7d_iotmaxx_gw4100_start +
+			    get_runtime_offset());
+}
diff --git a/arch/arm/dts/imx7d-iotmaxx-gw4100.dts b/arch/arm/dts/imx7d-iotmaxx-gw4100.dts
new file mode 100644
index 000000000000..0b1c019881c5
--- /dev/null
+++ b/arch/arm/dts/imx7d-iotmaxx-gw4100.dts
@@ -0,0 +1,147 @@
+#include <arm/imx7d-iotmaxx-gw4100.dts>
+
+/ {
+	aliases {
+		state = &state;
+		ethernet0 = &fec2;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x40000000>;
+        };
+
+	chosen {
+		stdout-path = &uart7;
+
+		environment-emmc {
+			compatible = "barebox,environment";
+			device-path = &bareboxenvemmc;
+			status = "disabled";
+		};
+
+		environment-sd {
+			compatible = "barebox,environment";
+			device-path = &bareboxenvsd;
+			status = "disabled";
+		};
+	};
+
+	state: state {
+		magic = <0x496f546d>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&state_emmc>;
+		backend-stridesize = <1024>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		bootstate {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			system0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				remaining_attempts {
+					reg = <0x0 0x4>;
+					type = "uint32";
+					default = <3>;
+				};
+				priority {
+					reg = <0x4 0x4>;
+					type = "uint32";
+					default = <21>;
+				};
+			};
+
+			system1 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				remaining_attempts {
+					reg = <0x10 0x4>;
+					type = "uint32";
+					default = <3>;
+				};
+				priority {
+					reg = <0x14 0x4>;
+					type = "uint32";
+					default = <20>;
+				};
+			};
+
+			last_chosen {
+				reg = <0x20 0x4>;
+				type = "uint32";
+			};
+		};
+	};
+};
+
+/* FIXME: unclear why barebox does not work with the linux settings */
+&fec2 {
+	assigned-clocks = <&clks IMX7D_ENET2_REF_ROOT_SRC>;
+	assigned-clock-parents = <&clks IMX7D_PLL_ENET_MAIN_50M_CLK>;
+	assigned-clock-rates = <50000000>;
+	clocks = <&clks IMX7D_ENET2_IPG_ROOT_CLK>,
+		 <&clks IMX7D_ENET_AXI_ROOT_CLK>,
+		 <&clks IMX7D_ENET2_TIME_ROOT_CLK>,
+		 <&clks IMX7D_PLL_ENET_MAIN_125M_CLK>,
+		 <&clks IMX7D_ENET_PHY_REF_ROOT_CLK>;
+	clock-names = "ipg", "ahb", "ptp",
+		      "enet_clk_ref", "enet_out";
+};
+
+/* FIXME: barebox serial is broken when barebox applies requested reparenting */
+&uart3 {
+	/delete-property/ assigned-clocks;
+	/delete-property/ assigned-clock-parents;
+};
+
+&uart4 {
+	/delete-property/ assigned-clocks;
+	/delete-property/ assigned-clock-parents;
+};
+
+&uart7 {
+	/delete-property/ assigned-clocks;
+	/delete-property/ assigned-clock-parents;
+};
+
+&usdhc2 {
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		barebox@0 {
+			label = "barebox";
+			reg = <0x0 0xe0000>;
+		};
+
+		bareboxenvsd: bareboxenv@e0000 {
+			label = "bareboxenv";
+			reg = <0xe0000 0x20000>;
+		};
+	};
+};
+
+&usdhc3 {
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		bareboxenvemmc: bareboxenv@100000 {
+			label = "bareboxenv";
+			reg = <0x100000 0x20000>;
+		};
+
+		state_emmc: state@120000 {
+			label = "state";
+			reg = <0x120000 0x20000>;
+		};
+	};
+};
